---
layout:      post
title:       "零散知识点"
subtitle:    "实战"
author:      "Ekko"
header-img:  "img/bg/bg-scattered.png"
catalog:     true
tags:
  - 学习笔记
  - 数据库
---

[TOC]

---

## 问题一：为什么越来越多人喜欢用构造器注入

1、不可变性 (Immutability)

构造器注入强制依赖项为 final，确保对象不可变

清晰的契约：对象创建时所有依赖必须就位

```java
@Service
public class UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final EmailService emailService;

    // 构造器注入 - 所有依赖都是 final
    public UserService(UserRepository userRepository, 
                      PasswordEncoder passwordEncoder,
                      EmailService emailService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.emailService = emailService;
    }
    
    // 业务方法...
}
```

2、依赖完整性保证

构造器注入确保对象在创建时所有依赖都可用

Setter注入，有一些场景下注入失败，运行的时候才会NPE异常

1. 缺少 @Component
2. 缺少 @Autowired
3. 复杂依赖关系
4. @PostConstruct 中使用

3、避免循环依赖问题

构造器注入能更早地暴露循环依赖问题

启动失败：BeanCurrentlyInCreationException

---

## 主线程等待子线程完成

CountDownLatch

Future

---

## 对象的创建过程

类加载检查
    ↓ （加载、验证、准备、解析、初始化）
内存分配
    ↓
初始化零值（默认值）
    ↓
设置对象头（MarkWord、类型指针）
    ↓
执行构造方法
    ↓
引用关联

---

## Http Referer

Referer 是HTTP请求头中的一个字段，表示当前请求是从哪个页面链接过来的

Referer 可以被伪造

---

## SimpleDateFormat 线程不安全

```java
public class SimpleDateFormat extends DateFormat {

}

public abstract class DateFormat extends Format {
    protected Calendar calendar;
}
```

Calendar 对象用于日期计算，这个对象的状态会在每次格式化和解析时被修改

解决方案：

1. jdk1.8   DateTimeFormatter

2. 每次使用的时候，new 新的 SimpleDateFormat 对象 （不推荐）

---

## 为什么 ConcurrentHashMap 不允许key为null

> value 也不允许为null，HashTable 线程安全也是一样逻辑

在并发环境中，存在歧义

1、key null 不存在 map 中

2、key null 存在，但是 value 是null

2种场景下返回的都是 null

总结：ConcurrentHashMap 为并发而生的，内部处理了所有线程安全问题，但为了清晰和安全，全面禁止null

---

### 问题一：HashMap 允许null，不会有歧义吗

会有歧义

HashMap 是高性能的单线程工具，如果要在多线程使用，就要自己处理所有同步问题

追求单线程下的极致性能，线程安全是使用者的责任

这是2种不同的设计思路

---

##  Java 中对象一定在堆上分配吗

不一定，普遍做法是在 堆 上分配

逃逸优化，HotSpot 默认启用该优化

> 逃逸优化：对象仅在方法内部使用，未被外部引用或线程共享，可能进行优化

处理方式：

1. 栈上分配，随方法结束自动销毁，无需GC介入
2. 标量替换，将对象拆解成基本类型（标量），存储在栈帧或寄存器，避免对象整体分配

---

## AOP什么时候失效

> @Transactional @Async 都是代理实现

1、 内部方法调用失效

内部调用通过 this 直接调用目标对象的方法，绕过了代理

解决方案：使用 AopContext.currentProxy()调用，需要开启 exposeProxy 配置

2、 非Spring管理的对象

通过 new 关键字直接创建对象，而不是通过 Spring 容器获取

---

## SpringBoot 自动装配原理

老项目，应该都写过 xml 吧，注入bean，依赖配置 bean 等等

SpringBoot 主要优化的就是这部分内容

@EnableAutoConfiguration -> 加载 Spring.factories -> 条件筛选(@Conditional) -> 动态注册Bean

启动类注解 @SpringBootApplication 包含了 @EnableAutoConfiguration

---

## 什么是 Spring

IOC、AOP

---

## 什么是 Spring MVC

DispatcherServlet、HandlerMapping、ModelAndView

---

## 什么是 SpringBoot

配置、内嵌 servlet 容器、jar包独立运行

---

## 什么是 SpringCloud

微服务框架集合，注册中心、网关、限流、负载均衡... ...