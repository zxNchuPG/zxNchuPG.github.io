---
layout:      post
title:       "redis持久化"
subtitle:    "Redis"
author:      "Ekko"
header-img:  "img/bg/bg-redis-2.jpg"
catalog:     true
tags:
  - 学习笔记
  - 缓存中间件
---

[TOC]

---

## RDB快照持久化

```conf
// RDB默认策略
save 900 1    # 900秒（15分钟）内至少有1个键被修改
save 300 10   # 300秒（5分钟）内至少有10个键被修改
save 60 10000 # 60秒（1分钟）内至少有10000个键被修改
```

**RDB文件内容：**

[魔数] → [版本号] → [可选元数据] → [数据库数据区] → [EOF 标记] → [校验和]

---

**魔数（Magic Number）：** 文件类型标识
1. 位置：文件最开头，占 5 字节
2. 内容：固定为字符串 REDIS 的 ASCII 编码（对应字节：0x52 0x45 0x44 0x49 0x53）
3. 作用：Redis 加载文件时，首先校验魔数，确认该文件是合法的 RDB 文件（避免加载非 RDB 格式的文件导致解析错误）

**版本号（RDB Version）：** 文件格式版本标识
1. 位置：魔数之后，占 4 字节
2. 内容：无符号大端整数（Big-Endian），表示 RDB 文件的格式版本（例如版本 9 对应字节 0x00 0x00 0x00 0x09）
3. 作用：不同版本的 RDB 文件可能在数据存储格式、元数据类型上有差异，Redis 依据版本号选择对应的解析逻辑（低版本 Redis 可能无法加载高版本 RDB 文件）

**可选元数据（Optional Metadata）：** 文件辅助信息
1. 位置：版本号之后，数据库数据区之前
2. 内容：非必需部分，不同版本可能包含不同的元数据，常见内容包括
    * Redis 服务器版本（如 6.2.6）
    * RDB 文件创建时间戳（Unix 时间戳，记录快照生成时间）
    * 快照生成时的 Redis 内存使用量
    * 保留字段（用于后续扩展）
3. 作用：主要用于调试和监控，帮助用户了解 RDB 文件的生成背景，不影响核心数据解析

**数据库数据区（Database Data）：** 核心数据存储

这是 RDB 文件中体积最大的部分，存储 Redis 所有数据库（默认 16 个，编号 0-15）的键值对数据，以及数据库的相关配置（如过期键、数据库为空标记等）

**EOF 标记：** 数据区结束标识

1. 位置：所有数据库数据存储完成后，占 1 字节
2. 内容：固定为 0xFF
3. 作用：明确告知解析器 “核心数据区已结束”，后续仅剩余校验和部分，避免解析时读取越界

**校验和（Checksum）：** 文件完整性校验
1. 位置：文件最后，占 8 字节
2. 内容：无符号大端整数，是对 RDB 文件中 “魔数 → EOF 标记” 前所有字节数据的校验值（默认使用 CRC64 算法，部分版本可能调整）
3. 作用：Redis 加载 RDB 文件时，会重新计算前面所有数据的校验值，与文件末尾的校验和对比：
若一致：文件未损坏，正常加载
若不一致：文件可能被篡改或传输过程中损坏，拒绝加载并抛出错误

---

### save 命令：同步阻塞，拒绝所有请求

**执行逻辑：** save 由 Redis 主进程直接遍历内存中的所有键值对，序列化后写入 RDB 文件。整个过程中，主进程无法处理任何客户端的读写请求（包括 GET、SET 等），客户端会收到 “服务暂时不可用” 的响应（或超时）

**阻塞时长：** 取决于数据集大小，数据量越大（如 10GB 内存），阻塞时间越长（可能几秒到几分钟）

**典型场景：** 仅建议在 Redis 关闭前执行（SHUTDOWN 命令会自动触发 SAVE，确保数据落盘），生产环境中禁止在服务运行时使用（会导致业务中断）

---

### bgsave 命令：异步非阻塞，主进程正常服务

**执行逻辑：** bgsave 由主进程调用 fork() 系统调用创建一个子进程，子进程负责生成 RDB 文件，主进程立即返回 “Background saving started” 并继续处理客户端命令

**潜在阻塞点：** 仅在 fork() 子进程的瞬间可能短暂阻塞主进程（时间取决于内存大小，大内存实例可能阻塞毫秒到秒级），之后主进程完全不受影响

**COW 机制影响：** 子进程生成快照期间，主进程修改的数据会触发 “写时复制”（COW）—— 被修改的内存页会被复制一份，子进程写入的是原内存数据，主进程修改的是新复制的内存页，两者互不干扰。但大量修改可能导致内存占用临时翻倍（需预留内存避免 OOM）

---

Redis 内部通过一个 “持久化状态标记”（server.bgsaveinprogress）确保 同一时间只有一个 RDB 快照操作（SAVE 或 BGSAVE）在执行

1. **禁止同时执行两个 SAVE：** 若已有一个 SAVE 在执行（主进程阻塞中），此时发送第二个 SAVE 命令，Redis 会直接拒绝，返回错误："ERR Background save already in progress"

2. **禁止同时执行两个 BGSAVE：** 若已通过 BGSAVE 启动子进程生成快照，此时再发送 BGSAVE 命令，Redis 会拒绝，返回同上错误（避免多个子进程同时占用 CPU/IO 资源）

3. **SAVE 与 BGSAVE 互斥：** 互相拒绝

---

### RDB文件生成过程

![RDB生成_1.png](/asserts/images/2025-10-19-redis持久化/RDB生成_1.png)

**save是主进程操作，所以会阻塞新进来的读写操作，下面是bgsave的过程**

1. 主进程准备：fork 子进程
2. 子进程生成 RDB 数据：遍历与序列化
3. 主进程的并发处理：写时复制（COW）保障数据一致性
    1. 极端情况下，假如所有的内存都被修改，那么此时的内存占用是原先的 2 倍
4. 子进程完成写入，原子替换目标文件
    1. 写临时文件，完成后，通过重命名覆盖旧的RDB文件
    2. 重命名完成后，子进程退出。操作系统会自动向其父进程（Redis 主进程）发送 SIGCHLD 信号（子进程状态改变的通知信号）。这一步是系统内核的默认行为，无需子进程主动调用发送信号的接口
5. 主进程清理资源与更新状态

---

## AOF持久化

```conf
always    # 每次写命令后立即刷盘（调用 fsync）
everysec   # 每秒刷盘一次（默认配置）
no # 由操作系统决定何时刷盘（通常依赖 OS 缓存，默认 30 秒左右）
```

1. 命令追加（Append）：记录写命令到缓冲区（AOF_BUF）
2. 文件同步（Sync）：缓冲区数据刷入磁盘

---

### 问题一：redis执行命令成功，但是在写AOF缓冲区的时候宕机

数据丢失

---

### 问题二：RDB文件bgsave，是fork子线程，AOF刷盘是由谁操作

AOF_BUF缓冲区的数据写入到 AOF 文件的操作，由**主进程**负责

1. appendfsync always：强阻塞，完全阻塞读写请求
    1. 执行逻辑：主进程执行完写命令后，必须立即调用 fsync() 系统调用，将 AOF 缓冲区中该命令的数据强制刷入磁盘，且需等待磁盘 IO 完成（得到磁盘确认）后，才会返回客户端结果并处理下一个请求。
    2. 阻塞表现：fsync() 是同步磁盘 IO 操作（速度为毫秒级，远慢于内存操作），期间主进程会被完全阻塞 —— 不仅无法处理新的写请求，也无法处理读请求，客户端会面临响应延迟甚至超时。
    3. 核心原因：该策略追求 “理论零数据丢失”，通过强阻塞保证命令与磁盘写入的原子性，代价是牺牲主进程的并发处理能力

2. appendfsync everysec（默认策略）：弱阻塞，几乎不影响读写
    1. 执行逻辑：主进程仅负责将写命令追加到 AOF 缓冲区（内存操作，微秒级，无阻塞）；同时启动一个独立的 后台线程（aof_fsync_thread），由线程每秒调用一次 fsync()，将缓冲区中积累的所有命令批量刷入磁盘。
    2. 阻塞表现：正常情况：主进程处理读写请求与后台线程执行 fsync() 并行，主进程无阻塞，服务响应不受影响；极端情况：若上一次 fsync() 未完成（如磁盘 IO 繁忙），下一次 fsync() 触发时，主进程可能会短暂阻塞（等待上一次 IO 完成），但阻塞时间通常极短（毫秒级），对业务影响可忽略。
    3. 核心原因：通过 “主进程处理命令 + 后台线程刷盘” 的分离设计，将磁盘 IO 开销转移到后台线程，最大化减少对主进程的阻塞
3. appendfsync no：无阻塞，完全不影响读写
    1. 执行逻辑：主进程仅将 AOF 缓冲区的数据写入 操作系统内核缓冲区（内存操作，无阻塞），不主动调用 fsync()；后续何时将内核缓冲区的数据刷入磁盘，完全由操作系统决定（通常依赖 OS 自身的缓存策略，如 30 秒一次）。
    2. 阻塞表现：主进程的操作仅限于 “内存到内核缓冲区”，全程无磁盘 IO 阻塞，可正常处理所有读写请求。
    3. 核心原因：放弃主动刷盘控制，将 IO 决策交给操作系统，以牺牲数据安全性为代价，换取主进程的极致性能

## AOF重写

AOF量太大，数据的中间态是无用的。比如插入、删除 同一条数据1w次，最终库中没有这个数据，但是AOF记录了1w次命令，这些命令是无效的。

重写策略就是生成一个新的 AOF 文件来代替旧的 AOF 文件，这个操作在满足一定条件 Redis 会自动触发

```conf
# 当前 AOF 文件体积 比上次重写后的体积增长了 100%（即翻倍）时，满足增长条件
auto-aof-rewrite-percentage 100

# 当当前 AOF 文件体积 至少达到 64MB 时，满足最小体积条件（避免小文件频繁重写）
auto-aof-rewrite-min-size 64mb
```

Redis 内部会定期（每 100 毫秒）检查以下两个条件：
1. 当前 AOF 文件体积 > 上次重写后的体积 × (1 + 百分比 / 100)（例如，上次重写后体积为 64MB，当前体积需 > 128MB 才满足 100% 增长）；
2. 当前 AOF 文件体积 ≥ auto-aof-rewrite-min-size（如 64MB）。

若同时满足，自动触发 BGREWRITEAOF 执行重写

> 特殊情况：若从未执行过重写（首次触发），“上次重写后的体积” 按 0 计算，此时只要当前体积 ≥ 最小体积，且增长百分比条件默认满足（0 的 100% 还是 0），即会触发首次重写

AOF 重写不依赖原 AOF 文件的内容，而是直接遍历 Redis 内存中的所有键值对，为每个键生成 “构建当前状态” 的最少命令。这避免了分析原 AOF 文件的复杂逻辑（原文件可能包含海量历史命令），且能保证生成的命令集绝对精简

---

### AOF重写过程

1. 主进程 fork 子进程
    1. 子进程继承主进程在 fork 时刻的 内存数据快照（通过写时复制 COW 机制共享内存，初始不复制实际数据）

2. 子进程生成新 AOF 文件
    1. 创建临时文件：在 dir 配置的路径下创建临时文件（如 temp-rewriteaof-xxx.aof），避免直接覆盖原文件（防止重写失败导致文件损坏）
    2. 遍历内存数据：按数据库（0-15 号库）顺序遍历所有键值对，为每个键生成精简命令（如合并后的 SET、HSET 等）
    3. 写入临时文件：将生成的命令按 Redis 协议格式写入临时文件（与原 AOF 格式一致，保证兼容性）

3. 主进程处理新命令（双缓冲区机制）

4. 合并新命令 + 原子替换（重命名覆盖）
当子进程完成新 AOF 文件的生成后（所有内存快照的命令已写入临时文件）
    1. 子进程退出并发送信号：子进程执行 exit() 退出，操作系统向主进程发送 SIGCHLD 信号
    2. 主进程合并新命令：主进程收到信号后，将 AOF 重写缓冲区 中所有暂存的新命令（重写期间的命令）追加到临时新文件（确保新文件包含 “快照 + 重写期间的新命令”，数据完整）
    3. 原子替换旧文件：主进程调用 rename() 系统调用，将临时文件原子性重命名为原 AOF 文件名（如 appendonly.aof），覆盖旧文件
    4. 清理资源：主进程更新重写状态（如记录 aof_last_rewrite_time），释放重写缓冲区，重写完成

---

### 问题一：AOF重写的时候，怎么保证新来的指令最终一致

重写期间（子进程生成新文件的同时），主进程仍需处理客户端的新写命令，为避免这些命令丢失，主进程会将新命令 同时追加到两个缓冲区：

1. **AOF 缓冲区（AOF_BUF）：** 继续按 appendfsync 策略同步到 旧 AOF 文件（确保旧文件的连续性，若重写失败，旧文件仍可用于恢复）；
2. **AOF 重写缓冲区（Rewrite Buffer）：** 专门暂存重写期间的新命令（子进程不知道这些命令，因为它基于 fork 时的快照工作）

---

### 问题二：AOF重写失败

重写过程中，旧 AOF 文件仍在被 AOF_BUF 同步（正常写入新命令），即使重写出错，旧文件也能保证数据不丢失。这也是为什么最后的收尾工作，是由主进程操作，并完成最后的文件重命名覆盖

---

## 主从同步

> redis2.8版本变动较大，主要体现在 psync 命令


